package med.features.rt;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.smodel.AttributesRolesUtil;
import java.util.List;
import jetbrains.mps.lang.structure.behavior.AbstractConceptDeclaration_Behavior;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;

public class FeatureDependencyChecker {
  private static SNode trueClause;

  public FeatureDependencyChecker() {
  }

  public static void checkModel(SNode treeRoot) {

    trueClause = SConceptOperations.createNewNode("med.features.structure.FeatureClause", null);
    SLinkOperations.setNewChild(trueClause, "expression", "med.features.structure.TrueFE");

    for (SNode node : ListSequence.fromList(SNodeOperations.getDescendants(treeRoot, "jetbrains.mps.lang.core.structure.BaseConcept", true, new String[]{})).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return !(SNodeOperations.isInstanceOf(it, "med.features.structure.BaseFE"));
      }
    })) {
      checkFeatureDependentSubtree(node, buildCompositeClause(node));
    }

  }

  public static SNode buildCompositeClause(SNode node) {
    SNode result = SConceptOperations.createNewNode("med.features.structure.FeatureClause", null);
    SNode and = SConceptOperations.createNewNode("med.features.structure.ListAndClause", null);
    SLinkOperations.setTarget(result, "expression", and, true);
    SNode current = node;
    while (current != null) {
      SNode ann = SLinkOperations.getTarget(current, AttributesRolesUtil.childRoleFromAttributeRole("featureDependencyAnnotation"), true);
      if ((ann != null)) {
        SLinkOperations.addChild(and, "elements", SNodeOperations.copyNode(SLinkOperations.getTarget(ann, "expression", true)));
      }
      current = SNodeOperations.getParent(current);
    }
    return result;
  }

  public static void checkFeatureDependentSubtree(SNode root, SNode referringClause) {
    for (SNode node : ListSequence.fromList(SNodeOperations.getDescendants(root, "jetbrains.mps.lang.core.structure.BaseConcept", true, new String[]{})).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return !(SNodeOperations.isInstanceOf(it, "med.features.structure.BaseFE"));
      }
    })) {
      List<SNode> references = AbstractConceptDeclaration_Behavior.call_getReferenceLinkDeclarations_1213877394496(SNodeOperations.getConceptDeclaration(node));
      if (ListSequence.fromList(references).isEmpty()) {
        return;
      }
      for (SNode l : ListSequence.fromList(references)) {
        SNode referencingSNode = node;
        SNode referent = referencingSNode.getReferent(SPropertyOperations.getString(l, "role"));
        checkDependencies(node, referringClause, referent, buildCompositeClause(referent));
      }
    }
  }

  public static void checkDependencies(SNode referrer, SNode referrerClause, SNode referent, SNode referentClause) {
    List<List<SNode>> sourceConfigs = ValidationBaseBuilder.applicableConfigurations(referrerClause);
    List<List<SNode>> targetConfigs = ValidationBaseBuilder.applicableConfigurations(referentClause);
    SNode p = SConceptOperations.createNewNode("med.features.structure.DependencyProblem", null);
    SLinkOperations.setTarget(p, "source", referrer, false);
    SLinkOperations.setTarget(p, "target", referent, false);
    for (List<SNode> c : ListSequence.fromList(sourceConfigs)) {
      if (!(contains(targetConfigs, c))) {
        SNode ic = SConceptOperations.createNewNode("med.features.structure.InvalidConfig", null);
        SPropertyOperations.set(ic, "dependencyString", "" + ListSequence.fromList(c).toListSequence());
        SLinkOperations.addChild(p, "invalids", ic);
      }
    }
    if (ListSequence.fromList(SLinkOperations.getTargets(p, "invalids", true)).isNotEmpty()) {
      SLinkOperations.setTarget(p, "sourceExpression", SNodeOperations.copyNode(SLinkOperations.getTarget(referrerClause, "expression", true)), true);
      SLinkOperations.setTarget(p, "targetExpression", SNodeOperations.copyNode(SLinkOperations.getTarget(referentClause, "expression", true)), true);
      ValidationBaseBuilder.reportProblem(p);
    }
  }

  public static boolean contains(List<List<SNode>> configs, List<SNode> candidate) {
    for (List<SNode> nl : ListSequence.fromList(configs)) {
      if (isTheSame(nl, candidate)) {
        return true;
      }
    }
    return false;
  }

  public static boolean isTheSame(List<SNode> l1, List<SNode> l2) {
    if (ListSequence.fromList(l1).count() != ListSequence.fromList(l2).count()) {
      return false;
    }
    for (SNode el : ListSequence.fromList(l1)) {
      if (!(ListSequence.fromList(l2).contains(el))) {
        return false;
      }
    }
    return true;
  }

  public static void printList(List<SNode> nl) {
    for (SNode fd : ListSequence.fromList(nl)) {
      System.err.print(fd + ", ");
    }
  }
}
